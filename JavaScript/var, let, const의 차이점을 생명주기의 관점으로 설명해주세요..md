# var, let, const의 차이점을 생명주기의 관점으로 설명해주세요.
<br/>

## 면접 답변

var, let, const의 차이점을 생명주기 관점에서 설명해 드리겠습니다.

**var**는 함수 스코프로 생명주기가 관리됩니다. 함수가 실행될 때 메모리에 할당되고, 함수 실행이 종료될 때 메모리에서 해제됩니다. var의 특징적인 생명주기는 호이스팅 과정에서 드러나는데, 선언과 동시에 undefined로 초기화되어 선언 이전에도 접근이 가능합니다. 따라서 var로 선언된 변수는 선언 전에도 접근이 가능하지만 값은 undefined입니다. 한편 전역에서 선언된 var 변수는 전체 프로그램 생명주기와 일치하여 메모리 누수의 원인이 될 수 있습니다.

**let**은 블록 스코프로 생명주기가 관리됩니다. 변수가 선언된 블록이 실행될 때 메모리에 공간이 할당되지만, 실제 초기화는 선언문에 도달할 때까지 이루어지지 않습니다. 이 과정에서 TDZ라는 생명주기 단계가 존재하며, 이 구간에서 변수에 접근하면 참조 오류가 발생합니다. 블록 실행이 종료되면 let 변수는 자동으로 메모리에서 해제되어 메모리 관리가 더 효율적입니다. 이러한 명확한 생명주기는 코드의 예측 가능성을 높여줍니다.

**const**는 let과 동일한 블록 스코프 생명주기를 가지지만, 초기화 시점에서 차이가 있습니다. const는 선언과 동시에 초기화가 반드시 이루어져야 하며, 한번 초기화된 후에는 같은 메모리 주소를 가리키는 참조가 변경될 수 없습니다. 이는 변수의 생명주기 동안 값의 불변성을 보장합니다. 하지만 참조하는 객체의 내부 속성은 변경될 수 있습니다. const의 생명주기도 블록 실행이 종료되면 끝나 메모리 효율성을 유지합니다.

<br/>
<hr/>
<br/>

## 개념 설명
### var의 생명주기

var로 선언된 변수는 함수 스코프 내에서 생명주기가 관리됩니다. 

### 특징

- **선언과 초기화**: var 변수는 런타임 이전에 자바스크립트 엔진에 의해 선언 단계와 초기화 단계가 동시에 이루어집니다.
- **스코프**: 함수 스코프를 가집니다. 함수 내에서 선언되면 함수 내에서만 접근 가능하고, 함수 외부에서 선언되면 전역 변수가 됩니다.
- **호이스팅**: 변수 선언이 코드 실행 전에 스코프의 최상단으로 끌어올려집니다. 선언만 호이스팅되고 초기화는 해당 라인에서 이루어집니다.
- **재선언/재할당**: 동일한 스코프 내에서 재선언과 재할당이 모두 가능합니다.
- **생명주기**: 함수 스코프 내에서 선언된 경우 함수 실행이 종료될 때까지 전역에서 선언된 경우 프로그램이 종료될 때까지 유지됩니다.
- **메모리 관리**: 전역에서 선언된 var 변수는 전체 프로그램 생명주기와 일치하여 메모리를 계속 차지하므로 메모리 누수의 원인이 될 수 있습니다.

![Image](https://github.com/user-attachments/assets/88b034e8-cbe7-42fa-a08f-4a05c8f8d159)

```jsx
console.log(foo); //undefined (에러가 발생하지 않음)
var foo;
console.log(foo); // undefined
foo = 1; // 할당문에서 할당 단계가 실행
console.log(foo); // 1
```

### let의 생명주기

let으로 선언된 변수는 블록 스코프 내에서 생명주기가 관리됩니다. 

### 특징

- **스코프**: 블록 스코프를 가집니다. 변수가 선언된 블록({}) 내에서만 접근 가능합니다.
- **선언과 초기화의 분리**: let 변수는 '선언 단계'와 '초기화 단계'가 분리되어 진행됩니다. 선언 단계는 런타임 이전에 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행됩니다.
- **호이스팅**: 호이스팅은 되지만 TDZ(스코프의 시작 지점부터 초기화 시점까지 변수를 참조할 수 없는 구간)로 인해 선언 전에 접근하게되면 ReferenceError가 발생 에러가 발생합니다.
- **재선언/재할당**: 동일한 블록 내에서 재선언은 불가능하지만, 재할당은 가능합니다.
- **생명주기**: 변수가 선언된 블록이 실행을 마칠 때 종료됩니다.
- **메모리 관리**: 블록 실행이 종료되면 let 변수는 자동으로 메모리에서 해제되어 메모리 관리가 더 효율적입니다.

![Image](https://github.com/user-attachments/assets/bd499922-ce43-40b6-9a9b-333f30a657d9)

```jsx

// TDZ 구간 시작
console.log(foo); // ReferenceError: foo is not defined
let foo; // 초기화 단계 실행 TDZ 종료
console.log(foo); // undefined
foo = 1; // 할당문에서 할당 단계가 실행
console.log(foo); // 1
```
### TDZ(일시적 사각지대)의 중요성

- **TDZ?**
    
    let과 const는 선언과 초기화가 분리되어 진행되며 선언문에 도달하기 전까지는 TDZ 구간에 있어 변수에 접근하면 ReferenceError가 발생합니다.
    
- **TDZ가 없다면 ?**
    
    var처럼 선언 이전에 접근 시 undefined가 반환되어 의도하지 않은 동작이나 버그가 발생할 수 있습니다.
    
- **TDZ가 있으면?**
    
    잘못된 접근을 방지해 코드의 안정성을 보장합니다. `//3개를 한줄로!!`
    

```jsx

console.log(a); // ReferenceError (TDZ에 있음)
let a = 5;
console.log(a); //  5
```

- var는 TDZ 없이 호이스팅되어 선언 이전에도 접근 가능하지만, let과 const는 TDZ로 인해 명확한 초기화 시점을 갖습니다.

### const의 생명주기

const로 선언된 변수는 let과 유사한 생명주기를 가지지만, 선언과 초기화 방식,재할당 방식에서 차이점이 있습니다.

### 특징

- **선언과 초기화의 통합**: const 변수는 선언과 동시에 반드시 초기화가 이루어져야 합니다
- **TDZ**: let과 마찬가지로 TDZ가 존재하며, 선언 전에 접근하면 ReferenceError가 발생합니다.
- **재할당 금지**: 생명주기 동안 같은 메모리 주소를 가리키는 참조가 변경될 수 없으며 변수의 불변성을 보장합니다.
- **객체의 내부 변경**: 객체나 배열 같은 참조 타입을 할당한 경우 재할당은 불가능하지만 내부 속성은 변경 가능합니다. 즉 바구니는 바꿀 수 없지만 바구니 안의 내용물은 바꿀 수 있습니다.
- **스코프**: let과 마찬가지로 블록 스코프를 가집니다.
- **생명주기**: let과 동일하게 블록 실행이 종료될 때 함께 종료됩니다.

```jsx
// TDZ 구간 시작
console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
const foo = 1; // 선언과 초기화가 동시에 이루어짐, TDZ 종료
console.log(foo); // 1
foo = 2; // TypeError: Assignment to constant variable
```

### const와 불변성의 관계

- **const가 변경 불가능하다는 표현의 의미는?**
    
    const는 재할당이 불가능하지만  객체 내부의 값은 변경 가능합니다. 메모리 주소(참조)는 고정되지만 해당 주소에 저장된 데이터는 변경될 수 있습니다.
    

```jsx

const person = { name: "지수" };
person.name = "수지";  // 객체 내부 값은 변경 가능

person = {}; // 재할당은 불가능하여 TypeError 발생

```

- const는 변수 자체의 참조를 변경할 수 없도록 하여, 변수의 불변성을 보장하지만 내부 데이터의 변경은 허용합니다.