# 실행 컨텍스트에 대해서 설명해 주세요.

<br/>

## 면접용

실행 컨텍스트는 자바스크립트가 코드를 실행할 때 변수를 기억하고, 실행 순서를 관리하는 공간입니다. 전역 실행 컨텍스트, 함수 실행 컨텍스트, 그리고 Eval 실행 컨텍스트 이렇게 세 가지가 있습니다.

전역 실행 컨텍스트는 코드가 처음 실행될 때 만들어지고, 전역 변수나 this 같은 정보가 저장됩니다.

함수 실행 컨텍스트는 함수를 호출할 때마다 생성되며, 함수 내부에서 선언된 변수나 매개변수 같은 것들이 저장됩니다. 실행이 끝나면 사라집니다.

Eval 실행 컨텍스트는 eval() 함수를 사용할 때 만들어지는데, 일반적으로 잘 사용되지 않습니다.

자바스크립트는 실행 컨텍스트를 스택(Stack) 구조로 관리합니다. 함수가 실행될 때마다 위에 쌓이고, 실행이 끝나면 가장 위에 있는 컨텍스트부터 제거됩니다.

<br/>

<hr/>
<br/>

## 개념 설명

### 실행 컨텍스트(Execution Context)란?

실행 컨텍스트는 **자바스크립트 코드가 실행되는 환경**을 의미하며, 코드의 실행 순서와 변수, 함수의 접근 범위를 관리하는 중요한 개념입니다.

자바스크립트는 싱글 스레드(Single Thread) 기반으로 동작하며, 코드를 실행할 때 실행 컨텍스트를 생성하고 이를 콜 스택(Call Stack) 에 쌓아 실행 순서를 관리합니다.

<img width="751" alt="image" src="https://github.com/user-attachments/assets/0e800b52-0b21-4e60-8b19-653803c998c9" />
<div style="color:rgb(123, 123, 123)"><i>(이미지 출처: 모던 자바스크립트 딥다이브)</i></div>

### 실행 컨텍스트의 생성 과정

1. **생성(Create) 단계**
    - 실행할 코드를 평가하고, 변수 및 함수를 메모리에 등록
    - 변수는 `undefined`로 초기화되고, 함수는 메모리에 할당한다. (호이스팅 발생)
2. **초기화(Initialize) 단계**
    - `var`, `let`, `const` 선언된 변수들을 초기화
    - `this` 바인딩 설정
    - 함수 실행 시 매개변수를 할당한다.
3. **실행(Execute) 단계**
    - 실제 코드가 실행된다.
    - 변수에 값이 할당되고, 연산이 수행된다.

### 실행 컨텍스트의 종류

1. **전역 실행 컨텍스트 (Global Execution Context)**
    - 프로그램이 실행될 때 가장 먼저 생성되는 컨텍스트
    - 전역 코드(파일 전체에서 실행되는 코드)를 실행
    - `this`는 브라우저에서는 `window`, Node.js 환경에서는 `global`을 가리킨다.
2. **함수 실행 컨텍스트 (Function Execution Context)**
    - 함수가 호출될 때마다 생성되는 컨텍스트
    - 함수의 지역 변수, 매개변수, 내부 함수가 저장된다.
    - 함수 실행이 끝나면 컨텍스트가 콜 스택에서 제거된다.
3. **Eval 실행 컨텍스트 (Eval Execution Context)**
    - `eval()` 함수 실행 시 생성되는 컨텍스트 (보안 문제로 잘 사용되지 않음)

### 실행 컨텍스트 내부 구성 요소

1. **변수 환경(Variable Environment)**
    - `var` 선언된 변수, 함수 선언, `this` 등이 포함된다.
    - 초기화 이후에도 유지되는 값 (함수 실행 종료 후에도 존재 가능)
2. **렉시컬 환경(Lexical Environment)**
    - `let`, `const` 변수, 클로저 정보 등이 저장된다.
    - 실행 컨텍스트가 생성될 때 생성되며, 스코프 체인 관리
3. **this 바인딩(This Binding)**
    - 실행 컨텍스트에 따라 `this`가 어떤 객체를 가리키는지 결정된다.
    

### 실행 컨텍스트와 콜 스택(Call Stack)

1. **전역 실행 컨텍스트가 먼저 실행**되어 콜 스택에 쌓입니다.
2. **함수를 호출할 때마다 새로운 실행 컨텍스트가 생성**되어 콜 스택에 추가된다.
3. **함수 실행이 종료되면 실행 컨텍스트가 제거**되고, 이전 실행 컨텍스트로 돌아간다.

```jsx
function first() {
  console.log("First");
  second();
}

function second() {
  console.log("Second");
  third();
}

function third() {
  console.log("Third");
}

first();

```

### 실행 과정

1. `first()` 호출 → `first` 실행 컨텍스트 생성
2. `second()` 호출 → `second` 실행 컨텍스트 생성
3. `third()` 호출 → `third` 실행 컨텍스트 생성
4. `third` 실행 종료 → `third` 컨텍스트 제거
5. `second` 실행 종료 → `second` 컨텍스트 제거
6. `first` 실행 종료 → `first` 컨텍스트 제거
7. 전역 실행 컨텍스트 유지 (’콜 스택이 비워지면 다음 함수가 실행된다.’ 라는 말에서도 전역 컨텍스트는 유지됩니다.)

### 실행 컨텍스트와 클로저(Closure)

실행 컨텍스트는 함수가 실행될 때마다 생성되지만, **클로저**는 실행이 끝난 함수의 변수 환경을 유지할 수 있습니다.

```
function outer() {
  let count = 0;

  return function inner() {
    count++;
    console.log(count);
  };
}

const counter = outer();
counter(); // 1
counter(); // 2

```

- `outer()` 실행 후에도 `inner()`가 `count` 변수에 접근할 수 있습니다.
- 이를 **클로저(Closure)** 라고 합니다.
- 실행 컨텍스트 종료 후에도 변수가 유지되는 이유
    
    자바스크립트에서 함수가 실행되면, 함수 실행 컨텍스트가 생성되고, 실행이 끝나면 해당 실행 컨텍스트는 콜 스택에서 제거됩니다. 하지만, 내부 함수(`inner`)가 외부 함수(`outer`)의 변수(`count`)를 참조하고 있기 때문에, `count`가 포함된 렉시컬 환경이 가비지 컬렉션(GC)되지 않고 유지됩니다. 이를 클로저(Closure) 라고 합니다.